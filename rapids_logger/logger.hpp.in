/*
 * Copyright (c) 2024, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// TODO: Add RMM_EXPORT tags or equivalent

#pragma once

#ifdef RMM_BACKWARDS_COMPATIBILITY
#include <spdlog/spdlog.h>
#endif

#include <memory>
#include <string>

namespace @_RAPIDS_LOGGER_NAMESPACE@ {

namespace detail {

/**
 * @brief Returns the default log filename for the RMM global logger.
 *
 * If the environment variable `RAPIDS_DEBUG_LOG_FILE` is defined, its value is used as the path and
 * name of the log file. Otherwise, the file `@_RAPIDS_LOGGER_NAMESPACE@_log.txt` in the current working directory is used.
 *
 * @return std::string The default log file name.
 */
inline std::string default_log_filename()
{
  auto* filename = std::getenv("@_RAPIDS_LOGGER_MACRO_PREFIX@_DEBUG_LOG_FILE");
  return (filename == nullptr) ? std::string{"@_RAPIDS_LOGGER_NAMESPACE@_log.txt"} : std::string{filename};
}

/**
 * @brief Represent a size in number of bytes.
 */
struct bytes {
  std::size_t value;  ///< The size in bytes

  /**
   * @brief Construct a new bytes object
   *
   * @param os The output stream
   * @param value The size in bytes
   */
  friend std::ostream& operator<<(std::ostream& os, bytes const& value)
  {
    static std::array units{"B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"};

    int index = 0;
    auto size = static_cast<double>(value.value);
    while (size > 1024) {
      size /= 1024;
      index++;
    }
    return os << size << ' ' << units.at(index);
  }
};

/**
 * @class fake_logger_impl
 * @brief The fake implementation of the logger that performs no-ops.
 * This is the default behavior if real logging is not enabled.
 */
class fake_impl {
 public:
  fake_impl() = default;

  template <typename... Args>
  void log(Args&&... args)
  {
  }
};

// Forward declaration of the real implementation
struct impl;

}  // namespace detail

// These defines must be kept in sync with spdlog or bad things will happen!
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_TRACE    0
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_DEBUG    1
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_INFO     2
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_WARN     3
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_ERROR    4
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_CRITICAL 5
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_OFF      6

enum class level_enum : int32_t {
  trace    = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_TRACE,
  debug    = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_DEBUG,
  info     = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_INFO,
  warn     = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_WARN,
  error    = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_ERROR,
  critical = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_CRITICAL,
  off      = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_OFF,
  n_levels
};

/**
 * @class logger
 * @brief A logger class that either uses the real implementation (via spdlog) or performs no-ops if
 * not supported.
 */
class logger {
 public:
  /**
   * @brief Constructor for logger.
   * Initializes the logger based on whether logging is supported.
   */
#ifdef SUPPORTS_LOGGING
  logger(std::string name, std::string filename);
#else
  logger(std::string name, std::string filename) {}
#endif

  // Not default constructible.
  logger() = delete;

  /**
   * @brief Destructor for logger.
   */
#ifdef SUPPORTS_LOGGING
  inline ~logger();
#else
  ~logger() = default;
#endif

  /**
   * @brief Copy constructor for logger.
   */
  logger(logger const&) = delete;
  // delete copy assignment operator
  logger& operator=(logger const&) = delete;
  // default move constructor
  inline logger(logger&&);
  // default move assignment operator
  inline logger& operator=(logger&&);

  template <typename... Args>
  void log(level_enum lvl, std::string const& format, Args&&... args)
  {
    auto size = static_cast<size_t>(std::snprintf(nullptr, 0, format.c_str(), args...) + 1);
    if (size <= 0) { throw std::runtime_error("Error during formatting."); }
    std::unique_ptr<char[]> buf(new char[size]);
    std::snprintf(buf.get(), size, format.c_str(), args...);
    log(lvl, {buf.get(), buf.get() + size - 1});
  }

  inline void log(level_enum lvl, std::string const& message);

  template <typename... Args>
  void trace(std::string const& format, Args&&... args)
  {
    log(level_enum::trace, format, std::forward<Args>(args)...);
  }

  template <typename... Args>
  void debug(std::string const& format, Args&&... args)
  {
    log(level_enum::debug, format, std::forward<Args>(args)...);
  }

  template <typename... Args>
  void info(std::string const& format, Args&&... args)
  {
    log(level_enum::info, format, std::forward<Args>(args)...);
  }

  template <typename... Args>
  void warn(std::string const& format, Args&&... args)
  {
    log(level_enum::warn, format, std::forward<Args>(args)...);
  }

  template <typename... Args>
  void error(std::string const& format, Args&&... args)
  {
    log(level_enum::error, format, std::forward<Args>(args)...);
  }

  template <typename... Args>
  void critical(std::string const& format, Args&&... args)
  {
    log(level_enum::critical, format, std::forward<Args>(args)...);
  }

  /**
   * @brief Check at compile-time whether logging is supported.
   * @return `true` if logging is supported, `false` otherwise.
   */
  static constexpr bool supports_logging()
  {
#ifdef SUPPORTS_LOGGING
    return true;
#else
    return false;
#endif
  }

#ifndef RMM_BACKWARDS_COMPATIBILITY
 private:
#endif
// TODO: Support args to the impl constructor
#ifdef SUPPORTS_LOGGING
  std::unique_ptr<detail::impl> pImpl{};
#else
  std::unique_ptr<detail::fake_impl> pImpl{};
#endif
};

namespace detail {

#ifdef RMM_BACKWARDS_COMPATIBILITY
inline logger& default_logger();
inline spdlog::logger& logger();
#endif

}  // namespace detail

#ifdef RMM_BACKWARDS_COMPATIBILITY
inline logger& default_logger() { return detail::default_logger(); }

[[deprecated(
  "Support for direct access to spdlog loggers in rmm is planned for "
  "removal")]] inline spdlog::logger&
logger()
{
  return detail::logger();
}
#else
inline logger& default_logger()
{
  static logger logger_ = [] {
    logger logger_ {
      "RAPIDS", detail::default_log_filename()
    };
#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_INFO
#ifdef CUDA_API_PER_THREAD_DEFAULT_STREAM
    logger_.info("----- RAPIDS LOG BEGIN [PTDS ENABLED] -----");
#else
    logger_.info("----- RAPIDS LOG BEGIN [PTDS DISABLED] -----");
#endif
#endif
    return logger_;
  }();
  return logger_;
}
#endif

// Macros for easier logging, similar to spdlog.
// TODO: Assumes that we want to respect spdlog's own logging macro level settings.
#define RMM_LOGGER_CALL(logger, level, ...) (logger).log(level, __VA_ARGS__)

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_TRACE
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_TRACE(...) \
  @_RAPIDS_LOGGER_MACRO_PREFIX@_LOGGER_CALL(@_RAPIDS_LOGGER_NAMESPACE@::default_logger(), @_RAPIDS_LOGGER_NAMESPACE@::level_enum::trace, __VA_ARGS__)
#else
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_TRACE(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_DEBUG
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_DEBUG(...) \
  @_RAPIDS_LOGGER_MACRO_PREFIX@_LOGGER_CALL(@_RAPIDS_LOGGER_NAMESPACE@::default_logger(), @_RAPIDS_LOGGER_NAMESPACE@::level_enum::debug, __VA_ARGS__)
#else
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_DEBUG(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_INFO
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_INFO(...) @_RAPIDS_LOGGER_MACRO_PREFIX@_LOGGER_CALL(@_RAPIDS_LOGGER_NAMESPACE@::default_logger(), @_RAPIDS_LOGGER_NAMESPACE@::level_enum::info, __VA_ARGS__)
#else
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_INFO(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_WARN
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_WARN(...) @_RAPIDS_LOGGER_MACRO_PREFIX@_LOGGER_CALL(@_RAPIDS_LOGGER_NAMESPACE@::default_logger(), @_RAPIDS_LOGGER_NAMESPACE@::level_enum::warn, __VA_ARGS__)
#else
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_WARN(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_ERROR
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_ERROR(...) \
  @_RAPIDS_LOGGER_MACRO_PREFIX@_LOGGER_CALL(@_RAPIDS_LOGGER_NAMESPACE@::default_logger(), @_RAPIDS_LOGGER_NAMESPACE@::level_enum::error, __VA_ARGS__)
#else
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_ERROR(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_CRITICAL
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_CRITICAL(...) \
  @_RAPIDS_LOGGER_MACRO_PREFIX@_LOGGER_CALL(@_RAPIDS_LOGGER_NAMESPACE@::default_logger(), @_RAPIDS_LOGGER_NAMESPACE@::level_enum::critical, __VA_ARGS__)
#else
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_CRITICAL(...) (void)0
#endif

}  // namespace @_RAPIDS_LOGGER_NAMESPACE@

#ifdef @_RAPIDS_LOGGER_MACRO_PREFIX@_BACKWARDS_COMPATIBILITY
#include "logger_impl/logger_impl.hpp"
#endif
