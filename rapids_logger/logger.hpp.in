/*
 * Copyright (c) 2024, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <memory>
#include <ostream>
#include <string>
#include <vector>

#ifdef @_RAPIDS_LOGGER_MACRO_PREFIX@_SUPPORTS_LOGGING

// Forward declare spdlog types that are part of our public API.
namespace spdlog {
class logger;
namespace sinks {
class sink;
} // namespace sinks
using sink_ptr = std::shared_ptr<sinks::sink>;
}  // namespace spdlog

#endif

namespace @_RAPIDS_VISIBILITY_MACRO@ @_RAPIDS_LOGGER_NAMESPACE@ {

namespace detail {

/**
 * @brief Returns the default log filename for the RMM global logger.
 *
 * If the environment variable `RAPIDS_DEBUG_LOG_FILE` is defined, its value is used as the path and
 * name of the log file. Otherwise, the file `@_RAPIDS_LOGGER_NAMESPACE@_log.txt` in the current working directory is used.
 *
 * @return std::string The default log file name.
 */
inline std::string default_log_filename()
{
  auto* filename = std::getenv("@_RAPIDS_LOGGER_MACRO_PREFIX@_DEBUG_LOG_FILE");
  // TODO: Do we prefer rmm's default (a file rmm_log.txt) or cudf's default (a
  // stderr sink)? I think the latter is better.
  return (filename == nullptr) ? std::string{"@_RAPIDS_LOGGER_NAMESPACE@_log.txt"} : std::string{filename};
}

/**
 * @brief Represent a size in number of bytes.
 */
struct bytes {
  std::size_t value;  ///< The size in bytes

  /**
   * @brief Convert the size to a string representation.
   *
   * @return std::string The size as a string.
   */
  std::string to_string() const
  {
    static std::array units{"B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"};

    int index = 0;
    auto size = static_cast<double>(value);
    while (size > 1024) {
      size /= 1024;
      index++;
    }
    return std::to_string(size) + ' ' + units.at(index);
  }

};

/**
 * @brief Trait to check if a type has a `to_string()` method that returns a `std::string`.
 *
 * @tparam T The type to check.
 */
template <typename, typename = std::void_t<>>
struct has_to_string : std::false_type {};

template <typename T>
struct has_to_string<T, std::void_t<decltype(std::declval<T>().to_string())>>
    : std::is_same<decltype(std::declval<T>().to_string()), std::string> {};

}  // namespace detail

// These values must be kept in sync with spdlog!
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_TRACE    0
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_DEBUG    1
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_INFO     2
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_WARN     3
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_ERROR    4
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_CRITICAL 5
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_OFF      6

/**
 * @brief The log levels supported by the logger.
 *
 * These levels correspond to the levels defined by spdlog.
 */
enum class level_enum : int32_t {
  trace    = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_TRACE,
  debug    = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_DEBUG,
  info     = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_INFO,
  warn     = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_WARN,
  error    = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_ERROR,
  critical = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_CRITICAL,
  off      = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_OFF,
  n_levels
};


class sink {
#ifdef @_RAPIDS_LOGGER_MACRO_PREFIX@_SUPPORTS_LOGGING
 public:
  sink(spdlog::sink_ptr);
 private:
  spdlog::sink_ptr impl;
#else
 public:
  // Use a template to avoid needing a definition of spdlog's sink_ptr type.
  template <typename Sink>
  sink(Sink) {}
#endif
  friend class logger;
};

/**
 * @class logger
 * @brief A logger class that either uses the real implementation (via spdlog) or performs no-ops if
 * not supported.
 */
class logger {
 public:
#ifdef @_RAPIDS_LOGGER_MACRO_PREFIX@_SUPPORTS_LOGGING
  /**
   * @brief Construct a new logger object
   *
   * @param name The name of the logger
   * @param filename The name of the log file
   */
  logger(std::string name, std::string filename);

  /**
   * @brief Construct a new logger object
   *
   * @param name The name of the logger
   * @param stream The stream to log to
   */
  logger(std::string name, std::ostream& stream);

  /**
   * @brief Construct a new logger object
   *
   * @param name The name of the logger
   * @param sinks The sinks to log to
   *
   * Note that we must use a vector because initializer_lists are not flexible
   * enough to support programmatic construction in callers, and an
   * iterator-based API would require templating and thus exposing spdlog
   * types.
   */
  logger(std::string name, std::vector<std::shared_ptr<sink>> sinks);

  /**
   * @brief Destroy the logger object
   */
  ~logger();
#else
  logger(std::string name, std::string filename) {}
  logger(std::string name, std::ostream& stream) {}
  logger(std::string name, std::vector<std::shared_ptr<sink>> sinks) {}
  ~logger() = default;
#endif

  logger() = delete;  ///< Not default constructible
  logger(logger const&) = delete;  ///< Not copy constructible
  logger& operator=(logger const&) = delete;  ///< Not copy assignable

  logger(logger&&);  ///< @default_move_constructor
  logger& operator=(logger&&);  ///< @default_move_assignment{logger}

#ifdef @_RAPIDS_LOGGER_MACRO_PREFIX@_SUPPORTS_LOGGING
  /**
   * @brief Log a message at the specified level.
   *
   * This is the core logging routine that dispatches to spdlog.
   *
   * @param lvl The log level
   * @param message The message to log
   */
  void log(level_enum lvl, std::string const& message);

  /**
   * @brief Add a sink to the logger.
   *
   * @param sink The sink to add
   */
  void add_sink(spdlog::sink_ptr sink);

  /**
   * @brief Remove a sink from the logger.
   *
   * @param sink The sink to remove
   */
  void remove_sink(spdlog::sink_ptr sink);

  /**
   * @brief Get the current log level.
   *
   * @return The current log level
   */
  level_enum level() const;

  /**
   * @brief Set the log level.
   *
   * @param log_level The new log level
   */
  void set_level(level_enum log_level);

  /**
   * @brief Flush the logger.
   */
  void flush();

  /**
   * @brief Flush all writes on the specified level or above.
   */
  void flush_on(level_enum log_level);

  /**
   * @brief Get the current flush level.
   */
  level_enum flush_level() const;

  /**
   * @brief Check if the logger should log a message at the specified level.
   *
   * @param msg_level The level of the message
   * @return true if the message should be logged, false otherwise
   */
  bool should_log(level_enum msg_level) const;

  /**
   * @brief Set the pattern for the logger.
   *
   * @param pattern The pattern to use
   */
  void set_pattern(std::string pattern);

  /**
   * @brief Check if the logger supports logging.
   *
   * @return true if the logger supports logging, false otherwise
   */
  static constexpr bool supports_logging() { return true; }
#else
  void log(level_enum lvl, std::string const& message) {}
  // When logging is not supported we won't have a spdlog sink_ptr type defined
  // when this function is, so a template is used to capture the user's type.
  template <typename Sink>
  void add_sink(Sink sink) {}
  template <typename Sink>
  void remove_sink(Sink sink) {}
  level_enum level() const { return level_enum::off; }
  void set_level(level_enum log_level) {}
  void flush() {}
  void flush_on(level_enum log_level) {}
  level_enum flush_level() { return level_enum::off; }
  bool should_log(level_enum msg_level) const { return false; }
  void set_pattern(std::string pattern) {}
  static constexpr bool supports_logging() { return false; }
#endif

  /**
   * @brief Log a message at the specified level.
   *
   * This public log API allows users to pass format arguments to this function
   * a la printf. Any custom objects may be logged as long as the type
   * implements a `to_string` method. The corresponding format specifier in the
   * format string should simply be `%s` like for a normal string.
   *
   * @param lvl The log level
   * @param format The format string
   * @param args The format arguments
   */
  template<typename... Args>
  void log(level_enum lvl, std::string const& format, Args&&... args) {
    auto convert_to_string = [](auto&& arg) -> decltype(auto) {
      using ArgType = std::decay_t<decltype(arg)>;
      if constexpr (detail::has_to_string<ArgType>::value) {
        return arg.to_string();
      } else {
        return std::forward<decltype(arg)>(arg);
      }
    };

    this->formatted_log(lvl, format, convert_to_string(std::forward<Args>(args))...);
  };

  /**
   * @brief Log a message at the TRACE level.
   *
   * @param format The format string
   * @param args The format arguments
   */
  template <typename... Args>
  void trace(std::string const& format, Args&&... args)
  {
    log(level_enum::trace, format, std::forward<Args>(args)...);
  }

  /**
   * @brief Log a message at the DEBUG level.
   *
   * @param format The format string
   * @param args The format arguments
   */
  template <typename... Args>
  void debug(std::string const& format, Args&&... args)
  {
    log(level_enum::debug, format, std::forward<Args>(args)...);
  }

  /**
   * @brief Log a message at the INFO level.
   *
   * @param format The format string
   * @param args The format arguments
   */
  template <typename... Args>
  void info(std::string const& format, Args&&... args)
  {
    log(level_enum::info, format, std::forward<Args>(args)...);
  }

  /**
   * @brief Log a message at the WARN level.
   *
   * @param format The format string
   * @param args The format arguments
   */
  template <typename... Args>
  void warn(std::string const& format, Args&&... args)
  {
    log(level_enum::warn, format, std::forward<Args>(args)...);
  }

  /**
   * @brief Log a message at the ERROR level.
   *
   * @param format The format string
   * @param args The format arguments
   */
  template <typename... Args>
  void error(std::string const& format, Args&&... args)
  {
    log(level_enum::error, format, std::forward<Args>(args)...);
  }

  /**
   * @brief Log a message at the CRITICAL level.
   *
   * @param format The format string
   * @param args The format arguments
   */
  template <typename... Args>
  void critical(std::string const& format, Args&&... args)
  {
    log(level_enum::critical, format, std::forward<Args>(args)...);
  }

 private:
#ifdef @_RAPIDS_LOGGER_MACRO_PREFIX@_SUPPORTS_LOGGING
  std::unique_ptr<spdlog::logger> impl;
#endif

  // TODO: When we migrate to C++20 we can use std::format and format strings
  // instead of the printf-style printing used here.
  /**
   * @brief Format and log a message.
   *
   * This function performs printf-style formatting to avoid the need for fmt
   * or spdlog's own templated APIs (which would require exposing spdlog
   * symbols publicly) and then logs the formatted message.
   *
   * @param lvl The log level
   * @param format The format string
   * @param args The format arguments
   */
  template <typename... Args>
  void formatted_log(level_enum lvl, std::string const& format, Args&&... args) {
    auto convert_to_c_string = [](auto&& arg) -> decltype(auto) {
      using ArgType = std::decay_t<decltype(arg)>;
      if constexpr (std::is_same_v<ArgType, std::string>) {
        return arg.c_str();
      } else {
        return std::forward<decltype(arg)>(arg);
      }
    };

    auto size = static_cast<size_t>(std::snprintf(nullptr, 0, format.c_str(), convert_to_c_string(std::forward<Args>(args))...) + 1);
    if (size <= 0) { throw std::runtime_error("Error during formatting."); }
    std::unique_ptr<char[]> buf(new char[size]);
    std::snprintf(buf.get(), size, format.c_str(), convert_to_c_string(std::forward<Args>(args))...);
    log(lvl, {buf.get(), buf.get() + size - 1});
  }

#ifdef @_RAPIDS_LOGGER_MACRO_PREFIX@_SUPPORTS_LOGGING
  void init_logger();
#else
  void init_logger() {}
#endif
};

/**
 * @brief Get the default logger.
 *
 * @return logger& The default logger
 */
inline logger& default_logger()
{
  static logger logger_ = [] {
    logger logger_ {
      "RAPIDS", detail::default_log_filename()
    };
#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_INFO
#ifdef CUDA_API_PER_THREAD_DEFAULT_STREAM
    logger_.info("----- RAPIDS LOG BEGIN [PTDS ENABLED] -----");
#else
    logger_.info("----- RAPIDS LOG BEGIN [PTDS DISABLED] -----");
#endif
#endif
    return logger_;
  }();
  return logger_;
}

// Macros for easier logging, similar to spdlog.
// TODO: The macros below assume that we want to respect spdlog's level macros
// rather than the ones defined by this file.
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOGGER_CALL(logger, level, ...) (logger).log(level, __VA_ARGS__)

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_TRACE
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_TRACE(...) \
  @_RAPIDS_LOGGER_MACRO_PREFIX@_LOGGER_CALL(@_RAPIDS_LOGGER_NAMESPACE@::default_logger(), @_RAPIDS_LOGGER_NAMESPACE@::level_enum::trace, __VA_ARGS__)
#else
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_TRACE(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_DEBUG
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_DEBUG(...) \
  @_RAPIDS_LOGGER_MACRO_PREFIX@_LOGGER_CALL(@_RAPIDS_LOGGER_NAMESPACE@::default_logger(), @_RAPIDS_LOGGER_NAMESPACE@::level_enum::debug, __VA_ARGS__)
#else
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_DEBUG(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_INFO
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_INFO(...) @_RAPIDS_LOGGER_MACRO_PREFIX@_LOGGER_CALL(@_RAPIDS_LOGGER_NAMESPACE@::default_logger(), @_RAPIDS_LOGGER_NAMESPACE@::level_enum::info, __VA_ARGS__)
#else
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_INFO(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_WARN
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_WARN(...) @_RAPIDS_LOGGER_MACRO_PREFIX@_LOGGER_CALL(@_RAPIDS_LOGGER_NAMESPACE@::default_logger(), @_RAPIDS_LOGGER_NAMESPACE@::level_enum::warn, __VA_ARGS__)
#else
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_WARN(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_ERROR
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_ERROR(...) \
  @_RAPIDS_LOGGER_MACRO_PREFIX@_LOGGER_CALL(@_RAPIDS_LOGGER_NAMESPACE@::default_logger(), @_RAPIDS_LOGGER_NAMESPACE@::level_enum::error, __VA_ARGS__)
#else
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_ERROR(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_CRITICAL
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_CRITICAL(...) \
  @_RAPIDS_LOGGER_MACRO_PREFIX@_LOGGER_CALL(@_RAPIDS_LOGGER_NAMESPACE@::default_logger(), @_RAPIDS_LOGGER_NAMESPACE@::level_enum::critical, __VA_ARGS__)
#else
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_CRITICAL(...) (void)0
#endif

}  // namespace @_RAPIDS_LOGGER_NAMESPACE@
