/*
 * Copyright (c) 2024, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// TODO: Add RMM_EXPORT tags or equivalent

#pragma once

// TODO: For convenience, I'm defining all the macros here that we need for vim
// to render the desired bits of code.
#define SUPPORTS_LOGGING
#define RMM_BACKWARDS_COMPATIBILITY

#ifdef RMM_BACKWARDS_COMPATIBILITY
#include <spdlog/spdlog.h>
#endif

#include <memory>
#include <string>

namespace @_RAPIDS_LOGGER_NAMESPACE@ {

namespace detail {

/**
 * @class fake_logger_impl
 * @brief The fake implementation of the logger that performs no-ops.
 * This is the default behavior if real logging is not enabled.
 */
class fake_impl {
 public:
  fake_impl() = default;

  template <typename... Args>
  void log(Args&&... args)
  {
  }
};

// Forward declaration of the real implementation
struct impl;

}  // namespace detail

// These defines must be kept in sync with spdlog or bad things will happen!
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_TRACE    0
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_DEBUG    1
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_INFO     2
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_WARN     3
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_ERROR    4
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_CRITICAL 5
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_OFF      6

enum class level_enum : int32_t {
  trace    = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_TRACE,
  debug    = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_DEBUG,
  info     = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_INFO,
  warn     = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_WARN,
  error    = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_ERROR,
  critical = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_CRITICAL,
  off      = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_OFF,
  n_levels
};

/**
 * @class logger
 * @brief A logger class that either uses the real implementation (via spdlog) or performs no-ops if
 * not supported.
 */
class logger {
 public:
  /**
   * @brief Constructor for logger.
   * Initializes the logger based on whether logging is supported.
   */
#ifdef SUPPORTS_LOGGING
  logger(std::string name, std::string filename);
#else
  logger(std::string name, std::string filename) {}
#endif

  // Not default constructible.
  logger() = delete;

  /**
   * @brief Destructor for logger.
   */
#ifdef SUPPORTS_LOGGING
#ifdef RMM_BACKWARDS_COMPATIBILITY
  inline ~logger();
#else
  ~logger();
#endif
#else
  ~logger() = default;
#endif

  /**
   * @brief Copy constructor for logger.
   */
  logger(logger const&) = delete;
  // delete copy assignment operator
  logger& operator=(logger const&) = delete;
  // default move constructor
  logger(logger&&) = default;
  // default move assignment operator
  logger& operator=(logger&&) = default;

  template <typename... Args>
  void log(level_enum lvl, std::string const& format, Args&&... args)
  {
    auto size = static_cast<size_t>(std::snprintf(nullptr, 0, format.c_str(), args...) + 1);
    if (size <= 0) { throw std::runtime_error("Error during formatting."); }
    std::unique_ptr<char[]> buf(new char[size]);
    std::snprintf(buf.get(), size, format.c_str(), args...);
    log(lvl, {buf.get(), buf.get() + size - 1});
  }

#ifdef RMM_BACKWARDS_COMPATIBILITY
  inline void log(level_enum lvl, std::string const& message);
#else
  void log(level_enum lvl, std::string const& message);
#endif

  template <typename... Args>
  void trace(std::string const& format, Args&&... args)
  {
    log(level_enum::trace, format, std::forward<Args>(args)...);
  }

  template <typename... Args>
  void debug(std::string const& format, Args&&... args)
  {
    log(level_enum::debug, format, std::forward<Args>(args)...);
  }

  template <typename... Args>
  void info(std::string const& format, Args&&... args)
  {
    log(level_enum::info, format, std::forward<Args>(args)...);
  }

  template <typename... Args>
  void warn(std::string const& format, Args&&... args)
  {
    log(level_enum::warn, format, std::forward<Args>(args)...);
  }

  template <typename... Args>
  void error(std::string const& format, Args&&... args)
  {
    log(level_enum::error, format, std::forward<Args>(args)...);
  }

  template <typename... Args>
  void critical(std::string const& format, Args&&... args)
  {
    log(level_enum::critical, format, std::forward<Args>(args)...);
  }

  /**
   * @brief Check at compile-time whether logging is supported.
   * @return `true` if logging is supported, `false` otherwise.
   */
  static constexpr bool supports_logging()
  {
#ifdef SUPPORTS_LOGGING
    return true;
#else
    return false;
#endif
  }

#ifndef RMM_BACKWARDS_COMPATIBILITY
 private:
#endif
// TODO: Support args to the impl constructor
#ifdef SUPPORTS_LOGGING
  std::unique_ptr<detail::impl> pImpl{};
#else
  std::unique_ptr<detail::fake_impl> pImpl{};
#endif
};

namespace detail {

#ifdef RMM_BACKWARDS_COMPATIBILITY
#ifdef SUPPORTS_LOGGING
inline logger& default_logger();
#else
inline logger& default_logger()
{
  // This is a no-op so pass empty args.
  static class logger logger {
    "", ""
  };
  return logger;
}
#endif

#ifdef SUPPORTS_LOGGING
inline spdlog::logger& logger();
#else
inline spdlog::logger& logger()
{
  // This branch won't compile. It's not worth supporting since it's not a
  // real backwards-compat path.
}
#endif
#endif

}  // namespace detail

#ifdef RMM_BACKWARDS_COMPATIBILITY
inline logger& default_logger() { return detail::default_logger(); }

[[deprecated(
  "Support for direct access to spdlog loggers in rmm is planned for "
  "removal")]] inline spdlog::logger&
logger()
{
  return detail::logger();
}
#else
// TODO: Move the detail implementation of default_logger here.
#endif

// Macros for easier logging, similar to spdlog.
// TODO: Assumes that we want to respect spdlog's own logging macro settings.
// TODO: Should we switch this to use _LOGGER_ instead of _LOG_ to match SPDLOG
// instead of rmm? If we do that will be a breaking change for rmm.
// TODO: Should we support other signatures for log?
#define RMM_LOGGER_CALL(logger, level, ...) (logger).log(level, __VA_ARGS__)

// TODO: Need to define our own levels to map to spdlogs.
#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_TRACE
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_TRACE(...) \
  @_RAPIDS_LOGGER_MACRO_PREFIX@_LOGGER_CALL(@_RAPIDS_LOGGER_NAMESPACE@::default_logger(), @_RAPIDS_LOGGER_NAMESPACE@::level_enum::trace, __VA_ARGS__)
#else
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_TRACE(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_DEBUG
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_DEBUG(...) \
  @_RAPIDS_LOGGER_MACRO_PREFIX@_LOGGER_CALL(@_RAPIDS_LOGGER_NAMESPACE@::default_logger(), @_RAPIDS_LOGGER_NAMESPACE@::level_enum::debug, __VA_ARGS__)
#else
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_DEBUG(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_INFO
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_INFO(...) @_RAPIDS_LOGGER_MACRO_PREFIX@_LOGGER_CALL(@_RAPIDS_LOGGER_NAMESPACE@::default_logger(), @_RAPIDS_LOGGER_NAMESPACE@::level_enum::info, __VA_ARGS__)
#else
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_INFO(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_WARN
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_WARN(...) @_RAPIDS_LOGGER_MACRO_PREFIX@_LOGGER_CALL(@_RAPIDS_LOGGER_NAMESPACE@::default_logger(), @_RAPIDS_LOGGER_NAMESPACE@::level_enum::warn, __VA_ARGS__)
#else
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_WARN(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_ERROR
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_ERROR(...) \
  @_RAPIDS_LOGGER_MACRO_PREFIX@_LOGGER_CALL(@_RAPIDS_LOGGER_NAMESPACE@::default_logger(), @_RAPIDS_LOGGER_NAMESPACE@::level_enum::error, __VA_ARGS__)
#else
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_ERROR(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_CRITICAL
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_CRITICAL(...) \
  @_RAPIDS_LOGGER_MACRO_PREFIX@_LOGGER_CALL(@_RAPIDS_LOGGER_NAMESPACE@::default_logger(), @_RAPIDS_LOGGER_NAMESPACE@::level_enum::critical, __VA_ARGS__)
#else
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_CRITICAL(...) (void)0
#endif

}  // namespace @_RAPIDS_LOGGER_NAMESPACE@

#ifdef @_RAPIDS_LOGGER_MACRO_PREFIX@_BACKWARDS_COMPATIBILITY
#include <rmm/logger_impl.hpp>
#endif
