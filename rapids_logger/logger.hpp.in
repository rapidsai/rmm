/*
 * Copyright (c) 2024, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// TODO: Add RMM_EXPORT tags or equivalent

#pragma once

#ifdef RMM_BACKWARDS_COMPATIBILITY
#include <spdlog/spdlog.h>
#endif

// We only define functions as inline when in backwards compatibility mode
// because in that mode those functions are included in the header, just
// defined out of band by the include of logger_impl.hpp into this file. In the
// new mode the functions are defined in their own TU.
#ifdef RMM_BACKWARDS_COMPATIBILITY
#define BACKWARDS_COMPAT_INLINE inline
#else
#define BACKWARDS_COMPAT_INLINE
#endif

#include <memory>
#include <ostream>
#include <string>

#ifdef SUPPORTS_LOGGING
#include <initializer_list>

namespace spdlog {
namespace sinks {
class sink;
} // namespace sinks
using sink_ptr = std::shared_ptr<sinks::sink>;
}  // namespace spdlog

#endif

namespace @_RAPIDS_LOGGER_NAMESPACE@ {

namespace detail {

/**
 * @brief Returns the default log filename for the RMM global logger.
 *
 * If the environment variable `RAPIDS_DEBUG_LOG_FILE` is defined, its value is used as the path and
 * name of the log file. Otherwise, the file `@_RAPIDS_LOGGER_NAMESPACE@_log.txt` in the current working directory is used.
 *
 * @return std::string The default log file name.
 */
inline std::string default_log_filename()
{
  auto* filename = std::getenv("@_RAPIDS_LOGGER_MACRO_PREFIX@_DEBUG_LOG_FILE");
  return (filename == nullptr) ? std::string{"@_RAPIDS_LOGGER_NAMESPACE@_log.txt"} : std::string{filename};
}

/**
 * @brief Represent a size in number of bytes.
 */
struct bytes {
  std::size_t value;  ///< The size in bytes

#ifdef RMM_BACKWARDS_COMPATIBILITY
  /**
   * @brief Construct a new bytes object
   *
   * @param os The output stream
   * @param value The size in bytes
   */
  friend std::ostream& operator<<(std::ostream& os, bytes const& value)
  {
    static std::array units{"B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"};

    int index = 0;
    auto size = static_cast<double>(value.value);
    while (size > 1024) {
      size /= 1024;
      index++;
    }
    return os << size << ' ' << units.at(index);
  }
#else
  std::string to_string() const
  {
    static std::array units{"B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"};

    int index = 0;
    auto size = static_cast<double>(value);
    while (size > 1024) {
      size /= 1024;
      index++;
    }
    return std::to_string(size) + ' ' + units.at(index);
  }

#endif
};

// Forward declaration of the real implementation
struct impl;

// Trait to check if T has a to_string() method that returns std::string
template <typename, typename = std::void_t<>>
struct has_to_string : std::false_type {};

template <typename T>
struct has_to_string<T, std::void_t<decltype(std::declval<T>().to_string())>>
    : std::is_same<decltype(std::declval<T>().to_string()), std::string> {};

}  // namespace detail

// These defines must be kept in sync with spdlog or bad things will happen!
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_TRACE    0
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_DEBUG    1
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_INFO     2
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_WARN     3
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_ERROR    4
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_CRITICAL 5
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_OFF      6

enum class level_enum : int32_t {
  trace    = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_TRACE,
  debug    = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_DEBUG,
  info     = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_INFO,
  warn     = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_WARN,
  error    = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_ERROR,
  critical = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_CRITICAL,
  off      = @_RAPIDS_LOGGER_MACRO_PREFIX@_LEVEL_OFF,
  n_levels
};

/**
 * @class logger
 * @brief A logger class that either uses the real implementation (via spdlog) or performs no-ops if
 * not supported.
 */
class logger {
 public:
  /**
   * @brief Constructor for logger.
   * Initializes the logger based on whether logging is supported.
   */
#ifdef SUPPORTS_LOGGING
  BACKWARDS_COMPAT_INLINE logger(std::string name, std::string filename);
#else
  logger(std::string name, std::string filename) {}
#endif

  // Not default constructible.
  logger() = delete;

  /**
   * @brief Destructor for logger.
   */
#ifdef SUPPORTS_LOGGING
  BACKWARDS_COMPAT_INLINE ~logger();
#else
  ~logger() = default;
#endif

  /**
   * @brief Copy constructor for logger.
   */
  logger(logger const&) = delete;
  // delete copy assignment operator
  logger& operator=(logger const&) = delete;
  // default move constructor
  BACKWARDS_COMPAT_INLINE logger(logger&&);
  // default move assignment operator
  BACKWARDS_COMPAT_INLINE logger& operator=(logger&&);

  // This public log API allows users to pass format arguments to this function
  // a la printf.
  template<typename... Args>
  void log(level_enum lvl, std::string const& format, Args&&... args) {
    auto convert_to_string = [](auto&& arg) -> decltype(auto) {
      using ArgType = std::decay_t<decltype(arg)>;
      if constexpr (detail::has_to_string<ArgType>::value) {
        return arg.to_string();
      } else {
        return std::forward<decltype(arg)>(arg);
      }
    };

    this->_log(lvl, format, convert_to_string(std::forward<Args>(args))...);
  };

#ifdef SUPPORTS_LOGGING
  BACKWARDS_COMPAT_INLINE void log(level_enum lvl, std::string const& message);
#else
  void log(level_enum lvl, std::string const& message) {}
#endif

  template <typename... Args>
  void trace(std::string const& format, Args&&... args)
  {
    log(level_enum::trace, format, std::forward<Args>(args)...);
  }

  template <typename... Args>
  void debug(std::string const& format, Args&&... args)
  {
    log(level_enum::debug, format, std::forward<Args>(args)...);
  }

  template <typename... Args>
  void info(std::string const& format, Args&&... args)
  {
    log(level_enum::info, format, std::forward<Args>(args)...);
  }

  template <typename... Args>
  void warn(std::string const& format, Args&&... args)
  {
    log(level_enum::warn, format, std::forward<Args>(args)...);
  }

  template <typename... Args>
  void error(std::string const& format, Args&&... args)
  {
    log(level_enum::error, format, std::forward<Args>(args)...);
  }

  template <typename... Args>
  void critical(std::string const& format, Args&&... args)
  {
    log(level_enum::critical, format, std::forward<Args>(args)...);
  }

#ifdef SUPPORTS_LOGGING
  BACKWARDS_COMPAT_INLINE void add_sink(spdlog::sink_ptr sink);
  BACKWARDS_COMPAT_INLINE void remove_sink(spdlog::sink_ptr sink);
#else
  // When logging is not supported we won't have a spdlog sink_ptr type defined
  // when this function is, so a template is used to capture the user's type.
  template<typename Sink>
  void add_sink(Sink sink) {}
  template<typename Sink>
  void remove_sink(Sink sink) {}
#endif

#ifdef SUPPORTS_LOGGING
  BACKWARDS_COMPAT_INLINE level_enum level() const;
  BACKWARDS_COMPAT_INLINE void set_level(level_enum log_level);
  BACKWARDS_COMPAT_INLINE void flush();
#else
  BACKWARDS_COMPAT_INLINE level_enum level() const { return level_enum::off; }
  void set_level(level::level_enum log_level) {}
  void flush() {}
#endif

  /**
   * @brief Check at compile-time whether logging is supported.
   * @return `true` if logging is supported, `false` otherwise.
   */
  static constexpr bool supports_logging()
  {
#ifdef SUPPORTS_LOGGING
    return true;
#else
    return false;
#endif
  }

#ifndef RMM_BACKWARDS_COMPATIBILITY
 private:
#endif
// TODO: Support args to the impl constructor
#ifdef SUPPORTS_LOGGING
  std::unique_ptr<detail::impl> pImpl{};
#endif

#ifdef RMM_BACKWARDS_COMPATIBILITY
 private:
#endif
  // TODO: When we migrate to C++20 we can use std::format and format strings
  // instead of the printf-style printing used here.
  template <typename... Args>
  void formatted_log(level_enum lvl, std::string const& format, Args&&... args) {
    auto size = static_cast<size_t>(std::snprintf(nullptr, 0, format.c_str(), args...) + 1);
    if (size <= 0) { throw std::runtime_error("Error during formatting."); }
    std::unique_ptr<char[]> buf(new char[size]);
    std::snprintf(buf.get(), size, format.c_str(), args...);
    log(lvl, {buf.get(), buf.get() + size - 1});
  }

  // This second level of indirection preserves the lifetime of string
  // temporaries created in the log() call so that the c_str pointers are valid
  // in the subsequent formatted_log call.
  template<typename... Args>
  void _log(level_enum lvl, std::string const& format, Args&&... args) {
    auto convert_to_c_string = [](auto&& arg) -> decltype(auto) {
      using ArgType = std::decay_t<decltype(arg)>;
      if constexpr (std::is_same_v<ArgType, std::string>) {
        return arg.c_str();
      } else {
        return std::forward<decltype(arg)>(arg);
      }
    };

    this->formatted_log(lvl, format, convert_to_c_string(std::forward<Args>(args))...);
  };

};

namespace detail {

#ifdef RMM_BACKWARDS_COMPATIBILITY
inline logger& default_logger();
inline spdlog::logger& logger();
#endif

}  // namespace detail

#ifdef RMM_BACKWARDS_COMPATIBILITY
inline logger& default_logger() { return detail::default_logger(); }

[[deprecated(
  "Support for direct access to spdlog loggers in rmm is planned for "
  "removal")]] inline spdlog::logger&
logger()
{
  return detail::logger();
}
#else
inline logger& default_logger()
{
  static logger logger_ = [] {
    logger logger_ {
      "RAPIDS", detail::default_log_filename()
    };
#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_INFO
#ifdef CUDA_API_PER_THREAD_DEFAULT_STREAM
    logger_.info("----- RAPIDS LOG BEGIN [PTDS ENABLED] -----");
#else
    logger_.info("----- RAPIDS LOG BEGIN [PTDS DISABLED] -----");
#endif
#endif
    return logger_;
  }();
  return logger_;
}
#endif

// Macros for easier logging, similar to spdlog.
// TODO: Assumes that we want to respect spdlog's own logging macro level settings.
#define RMM_LOGGER_CALL(logger, level, ...) (logger).log(level, __VA_ARGS__)

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_TRACE
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_TRACE(...) \
  @_RAPIDS_LOGGER_MACRO_PREFIX@_LOGGER_CALL(@_RAPIDS_LOGGER_NAMESPACE@::default_logger(), @_RAPIDS_LOGGER_NAMESPACE@::level_enum::trace, __VA_ARGS__)
#else
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_TRACE(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_DEBUG
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_DEBUG(...) \
  @_RAPIDS_LOGGER_MACRO_PREFIX@_LOGGER_CALL(@_RAPIDS_LOGGER_NAMESPACE@::default_logger(), @_RAPIDS_LOGGER_NAMESPACE@::level_enum::debug, __VA_ARGS__)
#else
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_DEBUG(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_INFO
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_INFO(...) @_RAPIDS_LOGGER_MACRO_PREFIX@_LOGGER_CALL(@_RAPIDS_LOGGER_NAMESPACE@::default_logger(), @_RAPIDS_LOGGER_NAMESPACE@::level_enum::info, __VA_ARGS__)
#else
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_INFO(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_WARN
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_WARN(...) @_RAPIDS_LOGGER_MACRO_PREFIX@_LOGGER_CALL(@_RAPIDS_LOGGER_NAMESPACE@::default_logger(), @_RAPIDS_LOGGER_NAMESPACE@::level_enum::warn, __VA_ARGS__)
#else
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_WARN(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_ERROR
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_ERROR(...) \
  @_RAPIDS_LOGGER_MACRO_PREFIX@_LOGGER_CALL(@_RAPIDS_LOGGER_NAMESPACE@::default_logger(), @_RAPIDS_LOGGER_NAMESPACE@::level_enum::error, __VA_ARGS__)
#else
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_ERROR(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL <= SPDLOG_LEVEL_CRITICAL
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_CRITICAL(...) \
  @_RAPIDS_LOGGER_MACRO_PREFIX@_LOGGER_CALL(@_RAPIDS_LOGGER_NAMESPACE@::default_logger(), @_RAPIDS_LOGGER_NAMESPACE@::level_enum::critical, __VA_ARGS__)
#else
#define @_RAPIDS_LOGGER_MACRO_PREFIX@_LOG_CRITICAL(...) (void)0
#endif

}  // namespace @_RAPIDS_LOGGER_NAMESPACE@

#ifdef @_RAPIDS_LOGGER_MACRO_PREFIX@_BACKWARDS_COMPATIBILITY
#include "logger_impl/logger_impl.hpp"
#endif
